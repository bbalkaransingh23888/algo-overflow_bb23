### ARRAYS: EASY - TWO SUM ###

Question: Given an array of integers, return the indices of the two numbers
that add up to a given target.

ex: input => [1,3,7,9,2], t = 11; output => [3,4]
9+2=11 -> 9 is index 3, 2 is index 4 -> [3,4]
(1 is index 0, 3 is index 1, 7 is index 2)

Step 1: Verify the constraints (think about edgecases) => 
    - negative numbers or are all numbers positive?
    - are there duplicate numbers in the array or are they all unique?
    - will there always be a solution to the question or is it possible
    there is no possible solution? (an empty array or a one number array
    always wrong) => what do we return if there is no solution?
    - can multiple pairs add up to the given target value? 

Step 2: Write out test cases => 
    - Best case: input => [1,3,7,9,2], t = 11; output => [3,4] 
    - No solution: input => [1,3,7,9,2], t = 25; output => null
    - Empty array: input => [], t=1; output => null
    - One number array: input => [5], t=5; output => null (looking for a pair of numbers)
    - Low hanging fruit: input => [1,6], t=7; output => [0,1]

Step 3: Figure out a solution without code (pseudocode) =>
    - input => [1,3,7,9,2], t = 11
    - Try every pair of numbers => 1 + every other num in array, 3 + remainder, etc.
    until we find a pair that adds up to the target or go through every number without 
    finding a solution
    - Two pointer technique -> initialize 2 pointers and move them based on specified logic. 
        ex: p1 points to a specific number to test with other values, p2 represents
        the value p1 is being tested with at that time
    - number to find = target - nums[p1]
        ex: 11 - 1 = 10 = p2 -> after finding this value, compare it to each array 
        element. If the solution is found, p2 stops there. Otherwise, move p2. If p2 goes
        the entire array, p1 is moved over to the next array element and p2 is reset.
        nums = [1,3,7,9,2], t = 11; p2 = t - p1
            i)  p2 = 11 - 1 = 10 -> no possible answer
            ii) p2 = 11 - 3 = 8 -> no possible answer
            iii)p2 = 11 - 7 = 4 -> no possible answer 
            iv) p2 = 11 - 9 = 2 -> solution; 9 -> index 3, 2 -> index 4

Step 4: Brute Force Solution => Get to a working solution that is able to find
a solution if one exists and returns a message or something if there is no solution
available. See precourse-solutions.py Chapter 1: Section 1 for solution

Step 5: Code explanation => 
    - explanation: Pointer 1, or i, points to the first element in the array. Pointer
    2, or j, points to each element following i. i is set to iterate through
    the length of the array while j is set to iterate through the remainder 
    array that follows i. In order to get the solution, take the target and 
    subtract i from it, then see if it is the same as j. If so, return the indices
    of i and j. Otherwise, keep iterating through the array. If j iterates through the array
    without a solution, then i will be moved to the next element and j will be reset
    to the element folllowing i. If i iterates through the array without a 
    solution, return null because there is no solution based on the target
    and the array elements.

Step 6: Test the code against the edgecases =>
    - No solution: input => [1,3,7,9,2], t = 25; output => null
        status: complete
    - Empty array: input => [], t=1; output => null
        status: complete
    - One number array: input => [5], t=5; output => null (looking for a pair of numbers)
        status: complete
    - Low hanging fruit: input => [1,6], t=7; output => [0,1]
        status: complete

Step 7: Space and Time Complexity =>
    - How much of the time and space resources will consume relative to the input size,
    since inputs usually scale (in twoSum, the only part that scales is the nums array)
    - Time Complexity: How many more iterations does the code have to run if
    the code gets bigger (in twoSum, it's just the loops, which both have a 
    time complexity of N because if we have 8 more array elements, we will run 8
    more iterations. Combined, they will run in O(N^2)).
    - In Time Complexity, we think about the Time relationship of the iteration 
    relative to the size of the input itself. Therefore, if adding 4 elements to 
    the input array, it will lead to 4 more iterations of the pointer 1 (i)
    loop and 4 more iterations of the pointer 2 (j) loop for each i loop, meaning
    for each element there will be 4*4 more iterations of the function for each element
    added. 
    - For Space Complexity, since the code's just setting variables (pointer 
    1, or i, and pointer 2, or j), the Space Complexity is O(1), which 
    is the optimal Space Complexity.
    - There are two types of Complexities (for both Space and Time). One is Polynomial, and
    the other is Exponential. The difference between Polynomial and Exponential is
    that in Polynomial, the Base of the equation is dynamic but the Exponent is static
    assuming there is one, whereas in Exponential, the Exponent is dynamic. Examples of
    Polynomial complexities are O(LogN) - Logarithmic, O(N) - Linear, O(NLogN) - Linearithmic,
    O(N^2) - Quadritic, and O(N^3) - Cubic. Examples of Exponential are O(2^N) or O(N^N) - Exponential 
    and O(!N) - Factoral. Polynomial Complexities are generally favorable whereas
    Exponential Complexities are considered unfavorable. If your complexities end up
    being Exponential ones, the solution most likely can be optimized.

Step 8: Optimize the Solution See precourse-solutions.py 
Chapter 1: Section 2 for solution=>
    - Can the solution be optimized? If one Complexity is significantly better
    than the other, then the solution can be optimized. 
    - Utilize a Hash Map to optimize the solution. 
        i) [1,3,7,9,2], t = 11
        ii) Calculate the NTF (11 - 1 = 10, 11 - 3 = 8, 11 - 7 = 4, 
        11 - 9 = 2, 11 - 2 = 9) and add each to the 
        hash map
        iii)hash map = {10: 0, 8: 1, 4: 2, 2: 3, 9: 4}. Basically, we store the NTF 
        in the hash map as keys and the indices those numbers
        were found at as the values. 
        iv) Then, we compare i to the key

Step 9: Repeat Steps 5-7 with Optimized Solution:



### ARRAYS: MEDIUM - CONTAINER WITH MOST WATER ###

Question: Given an array of positive integers where each integer represents a vertical
line on a chart. Find two lines which together with the x-axis forms a container 
that can hold the greatest amount of water and the area of water held.

ex: => [1,8,6,2,9,4] -> each index is a height. The 8 and 9 heights form 
a container with the most water combined with the x-axis of 3 units. Because the area 
will be below the 9 due to the space left at the top of 8, the length becomes 8. 
The distance between each is 1, as in the difference between indexes. The difference between
the index of 9 (4) and the index of 8 (1) is 3, which will be our width. Therefore, 
the area will be 8*3 = 24. 


Step 1: Verify the constraints (think about edgecases) => 
    - Does the thickness of the lines affect the area?
    - Do the left and right sides of the graph count as walls?
    - Does a higher line inside the container affect the area?

Step 2: Write out test cases => 
    - Best Case: input => [7,1,2,3,9]; output => 7 * 4 = 28
    - Empty Array: input => []; output => 0
    - One value Array: input => [3]; output => 0
    - Not Obvious Answer: input => [6,9,3,4,5,8]; output => 8*4=32 > 5*6=30

Step 3: Figure out a solution without code (pseudocode) =>
    - input => [7,1,2,3,9]
    - we have to take the length based on the lower of every pair of 
    numbers in the array and multiply it by the width based on the difference 
    between the indices of the two numbers to find the areas of every container. 
    The greatest of these areas, as well as the array values that lead to that,
    will represent our solution to the container with most water
    - length * width = min(a,b) * (b[i]-a[i]); max_area = 0; a is pointer 1,
    b is pointer 2
    - min(7,1)*1-0 = 1*1 = 1; min(7,2)*2-0 = 4; min(7,3)*3-0 = 9; min(7,9)*4-0 = 28;
    max_area=28, shift a forward and reset b to next index element
    - min(1,2)*(2-1)=1; min(1,3)*(3-1)=2;min(1,9)*(4-1)=3; 
    max_area=28, shift a forward and reset b to next index element
    - min(2,3)*(3-2)=2; min(2,9)*(4-2)=4;
    max_area=28
    - min(3,9)*(4-3)=3;
    max_area=28, end of loop

Step 4: Brute Force Solution => Get to a working solution that is able to find
a solution if one exists and returns a message or something if there is no solution
available. See precourse-solutions.py Chapter 2: Section 1 for solution
